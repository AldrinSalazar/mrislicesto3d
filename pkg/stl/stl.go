package stl

import (
	"encoding/binary"
	"os"

	"gonum.org/v1/gonum/spatial/r3"
)

// Triangle represents a triangle in 3D space
type Triangle struct {
	Normal   [3]float32
	Vertex1  [3]float32
	Vertex2  [3]float32
	Vertex3  [3]float32
}

// MarchingCubes implements the marching cubes algorithm for isosurface extraction
type MarchingCubes struct {
	data        []float64
	width       int
	height      int
	depth       int
	isoLevel    float64
	scaleX      float32
	scaleY      float32
	scaleZ      float32
}

// NewMarchingCubes creates a new marching cubes instance
func NewMarchingCubes(data []float64, width, height, depth int, isoLevel float64) *MarchingCubes {
	return &MarchingCubes{
		data:     data,
		width:    width,
		height:   height,
		depth:    depth,
		isoLevel: isoLevel,
		scaleX:   1.0,
		scaleY:   1.0,
		scaleZ:   1.0,
	}
}

// SetScale sets the scale factors for the output mesh
func (mc *MarchingCubes) SetScale(x, y, z float32) {
	mc.scaleX = x
	mc.scaleY = y
	mc.scaleZ = z
}

// GenerateTriangles generates triangles using marching cubes algorithm
func (mc *MarchingCubes) GenerateTriangles() []Triangle {
	var triangles []Triangle

	// Process each cube in the volume
	for z := 0; z < mc.depth-1; z++ {
		for y := 0; y < mc.height-1; y++ {
			for x := 0; x < mc.width-1; x++ {
				// Get cube vertices
				v := mc.getCubeVertices(x, y, z)
				
				// Get cube configuration
				cubeIndex := mc.getCubeIndex(v)
				if cubeIndex == 0 || cubeIndex == 255 {
					continue
				}

				// Generate triangles for this cube
				tris := mc.generateCubeTriangles(x, y, z, v, cubeIndex)
				triangles = append(triangles, tris...)
			}
		}
	}

	return triangles
}

// SaveToSTL saves triangles to an STL file
func SaveToSTL(filename string, triangles []Triangle) error {
	file, err := os.Create(filename)
	if err != nil {
		return err
	}
	defer file.Close()

	// Write STL header (80 bytes)
	header := make([]byte, 80)
	copy(header, []byte("Binary STL file generated by MRISlicesTo3D"))
	if _, err := file.Write(header); err != nil {
		return err
	}

	// Write number of triangles
	numTriangles := uint32(len(triangles))
	if err := binary.Write(file, binary.LittleEndian, numTriangles); err != nil {
		return err
	}

	// Write each triangle
	for _, t := range triangles {
		// Write normal
		if err := binary.Write(file, binary.LittleEndian, t.Normal); err != nil {
			return err
		}
		// Write vertices
		if err := binary.Write(file, binary.LittleEndian, t.Vertex1); err != nil {
			return err
		}
		if err := binary.Write(file, binary.LittleEndian, t.Vertex2); err != nil {
			return err
		}
		if err := binary.Write(file, binary.LittleEndian, t.Vertex3); err != nil {
			return err
		}
		// Write attribute byte count (unused)
		attributeByteCount := uint16(0)
		if err := binary.Write(file, binary.LittleEndian, attributeByteCount); err != nil {
			return err
		}
	}

	return nil
}

// Helper functions for marching cubes

func (mc *MarchingCubes) getCubeVertices(x, y, z int) [8]float64 {
	var v [8]float64
	v[0] = mc.getValue(x, y, z)
	v[1] = mc.getValue(x+1, y, z)
	v[2] = mc.getValue(x+1, y+1, z)
	v[3] = mc.getValue(x, y+1, z)
	v[4] = mc.getValue(x, y, z+1)
	v[5] = mc.getValue(x+1, y, z+1)
	v[6] = mc.getValue(x+1, y+1, z+1)
	v[7] = mc.getValue(x, y+1, z+1)
	return v
}

func (mc *MarchingCubes) getValue(x, y, z int) float64 {
	if x < 0 || x >= mc.width || y < 0 || y >= mc.height || z < 0 || z >= mc.depth {
		return 0
	}
	return mc.data[z*mc.width*mc.height + y*mc.width + x]
}

func (mc *MarchingCubes) getCubeIndex(v [8]float64) int {
	index := 0
	for i := 0; i < 8; i++ {
		if v[i] < mc.isoLevel {
			index |= 1 << uint(i)
		}
	}
	return index
}

func (mc *MarchingCubes) generateCubeTriangles(x, y, z int, v [8]float64, cubeIndex int) []Triangle {
	var triangles []Triangle

	// Get edge vertices where the surface intersects
	var vertList [12][3]float32
	for i := 0; i < 12; i++ {
		if edgeTable[cubeIndex]&(1<<uint(i)) != 0 {
			edge := edges[i]
			v1 := v[edge[0]]
			v2 := v[edge[1]]
			t := (mc.isoLevel - v1) / (v2 - v1)
			
			p1 := vertices[edge[0]]
			p2 := vertices[edge[1]]
			
			vertList[i][0] = float32(float64(x) + float64(p1[0]) + t*(float64(p2[0])-float64(p1[0]))) * mc.scaleX
			vertList[i][1] = float32(float64(y) + float64(p1[1]) + t*(float64(p2[1])-float64(p1[1]))) * mc.scaleY
			vertList[i][2] = float32(float64(z) + float64(p1[2]) + t*(float64(p2[2])-float64(p1[2]))) * mc.scaleZ
		}
	}

	// Create triangles
	for i := 0; triTable[cubeIndex][i] != -1; i += 3 {
		var tri Triangle
		v1 := vertList[triTable[cubeIndex][i]]
		v2 := vertList[triTable[cubeIndex][i+1]]
		v3 := vertList[triTable[cubeIndex][i+2]]
		
		// Convert to Gonum vectors
		vec1 := r3.Vec{X: float64(v1[0]), Y: float64(v1[1]), Z: float64(v1[2])}
		vec2 := r3.Vec{X: float64(v2[0]), Y: float64(v2[1]), Z: float64(v2[2])}
		vec3 := r3.Vec{X: float64(v3[0]), Y: float64(v3[1]), Z: float64(v3[2])}
		
		// Calculate vectors for cross product
		edge1 := r3.Sub(vec2, vec1)
		edge2 := r3.Sub(vec3, vec1)
		
		// Calculate normal using cross product
		normal := r3.Cross(edge1, edge2)
		
		// Normalize the normal vector
		normalLength := r3.Norm(normal)
		if normalLength > 0 {
			normal = r3.Scale(1/normalLength, normal)
			tri.Normal = [3]float32{float32(normal.X), float32(normal.Y), float32(normal.Z)}
		}
		
		tri.Vertex1 = v1
		tri.Vertex2 = v2
		tri.Vertex3 = v3
		
		triangles = append(triangles, tri)
	}

	return triangles
}

// Lookup tables for marching cubes algorithm
var edges = [12][2]int{
	{0, 1}, {1, 2}, {2, 3}, {3, 0},
	{4, 5}, {5, 6}, {6, 7}, {7, 4},
	{0, 4}, {1, 5}, {2, 6}, {3, 7},
}

var vertices = [8][3]float32{
	{0, 0, 0}, {1, 0, 0}, {1, 1, 0}, {0, 1, 0},
	{0, 0, 1}, {1, 0, 1}, {1, 1, 1}, {0, 1, 1},
}

// Tables needed for marching cubes are now in tables.go